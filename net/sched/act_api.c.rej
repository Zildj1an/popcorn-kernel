--- net/sched/act_api.c
+++ net/sched/act_api.c
@@ -1524,6 +1524,7 @@ static int tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)
 
 struct tcf_action_net {
 	struct rhashtable egdev_ht;
+	struct list_head egdev_list;
 };
 
 static unsigned int tcf_action_net_id;
@@ -1671,6 +1672,7 @@ static int __tc_setup_cb_egdev_register(const struct net_device *dev,
 	tcf_action_egdev_put(egdev);
 	return err;
 }
+
 int tc_setup_cb_egdev_register(const struct net_device *dev,
 			       tc_setup_cb_t *cb, void *cb_priv)
 {
@@ -1683,6 +1685,46 @@ int tc_setup_cb_egdev_register(const struct net_device *dev,
 }
 EXPORT_SYMBOL_GPL(tc_setup_cb_egdev_register);
 
+/* TODO: this name (egdev) does not make sense at all anymore */
+int tc_setup_cb_egdev_all_register(const struct net_device *dev,
+				   tc_setup_cb_t *cb, void *cb_priv)
+{
+	struct tcf_action_egdev_cb *egdev_cb;
+	struct tcf_action_net *tan;
+
+	egdev_cb = kzalloc(sizeof(*egdev_cb), GFP_KERNEL);
+	if (!egdev_cb)
+		return -ENOMEM;
+	egdev_cb->cb = cb;
+	egdev_cb->cb_priv = cb_priv;
+
+	rtnl_lock();
+	tan = net_generic(dev_net(dev), tcf_action_net_id);
+	list_add_tail(&egdev_cb->list, &tan->egdev_list);
+	rtnl_unlock();
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tc_setup_cb_egdev_all_register);
+
+void tc_setup_cb_egdev_all_unregister(const struct net_device *dev,
+				      tc_setup_cb_t *cb, void *cb_priv)
+{
+	struct tcf_action_egdev_cb *egdev_cb;
+	struct tcf_action_net *tan;
+
+	rtnl_lock();
+	tan = net_generic(dev_net(dev), tcf_action_net_id);
+	list_for_each_entry(egdev_cb, &tan->egdev_list, list) {
+		if (egdev_cb->cb == cb && egdev_cb->cb_priv == cb_priv) {
+			list_del(&egdev_cb->list);
+			kfree(egdev_cb);
+			break;
+		}
+	}
+	rtnl_unlock();
+}
+EXPORT_SYMBOL_GPL(tc_setup_cb_egdev_all_unregister);
+
 static void __tc_setup_cb_egdev_unregister(const struct net_device *dev,
 					   tc_setup_cb_t *cb, void *cb_priv)
 {
@@ -1693,6 +1735,7 @@ static void __tc_setup_cb_egdev_unregister(const struct net_device *dev,
 	tcf_action_egdev_cb_del(egdev, cb, cb_priv);
 	tcf_action_egdev_put(egdev);
 }
+
 void tc_setup_cb_egdev_unregister(const struct net_device *dev,
 				  tc_setup_cb_t *cb, void *cb_priv)
 {
@@ -1714,10 +1757,29 @@ int tc_setup_cb_egdev_call(const struct net_device *dev,
 }
 EXPORT_SYMBOL_GPL(tc_setup_cb_egdev_call);
 
+/* TODO: The egdev_list list is not protected */
+int tc_setup_cb_egdev_all_call_fast(enum tc_setup_type type, void *type_data)
+{
+	struct tcf_action_net *tan = net_generic(&init_net, tcf_action_net_id);
+	struct tcf_action_egdev_cb *egdev_cb;
+	int ok_count = 0;
+	int err;
+
+	list_for_each_entry(egdev_cb, &tan->egdev_list, list) {
+		err = egdev_cb->cb(type, type_data, egdev_cb->cb_priv);
+		if (!err)
+			ok_count++;
+	}
+
+	return ok_count;
+}
+EXPORT_SYMBOL_GPL(tc_setup_cb_egdev_all_call_fast);
+
 static __net_init int tcf_action_net_init(struct net *net)
 {
 	struct tcf_action_net *tan = net_generic(net, tcf_action_net_id);
 
+	INIT_LIST_HEAD(&tan->egdev_list);
 	return rhashtable_init(&tan->egdev_ht, &tcf_action_egdev_ht_params);
 }
 
