--- drivers/mmc/host/dw_mmc.c
+++ drivers/mmc/host/dw_mmc.c
@@ -231,11 +231,36 @@ static bool dw_mci_ctrl_reset(struct dw_mci *host, u32 reset)
 	return true;
 }
 
-static void dw_mci_wait_while_busy(struct dw_mci *host, u32 cmd_flags)
+static void dw_mci_wait_while_busy(struct dw_mci *host, u32 cmd_flags,
+				   struct dw_mci_slot *slot)
 {
 	u32 status;
 
 	/*
+	 * Only one memory card should be selected at a time for command or data
+	 * transfer. For example, when a data transfer from a card occurs, a new
+	 * command should not be sent to another card; within the same card, a
+	 * new command is allowed to read the status, or to stop or abort the
+	 * current data transfer.
+	 */
+	status = mci_readl(host, CMD);
+	if (SDMMC_GET_CARD_NUM(status) != slot->id) {
+		/* Check the last command of the other card. */
+		if (readl_poll_timeout_atomic(host->regs + SDMMC_CMD,
+					      status,
+					      !(status & SDMMC_CMD_START),
+					      10, 500 * USEC_PER_MSEC))
+			dev_err(host->dev, "Busy; trying anyway\n");
+
+		/* Check the busy state of the other card. */
+		if (readl_poll_timeout_atomic(host->regs + SDMMC_STATUS,
+					      status,
+					      !(status & SDMMC_STATUS_BUSY),
+					      10, 500 * USEC_PER_MSEC))
+			dev_err(host->dev, "STATUS busy; trying anyway\n");
+	}
+
+	/*
 	 * Databook says that before issuing a new data transfer command
 	 * we need to check to see if the card is busy.  Data transfer commands
 	 * all have SDMMC_CMD_PRV_DAT_WAIT set, so we'll key off that.
@@ -260,12 +285,13 @@ static void mci_send_cmd(struct dw_mci_slot *slot, u32 cmd, u32 arg)
 
 	mci_writel(host, CMDARG, arg);
 	wmb(); /* drain writebuffer */
-	dw_mci_wait_while_busy(host, cmd);
-	mci_writel(host, CMD, SDMMC_CMD_START | cmd);
+	dw_mci_wait_while_busy(host, cmd, slot);
+	mci_writel(host, CMD, SDMMC_CMD_START | cmd |
+		   SDMMC_CMD_CARD_NUM(slot->id));
 
 	if (readl_poll_timeout_atomic(host->regs + SDMMC_CMD, cmd_status,
 				      !(cmd_status & SDMMC_CMD_START),
-				      1, 500 * USEC_PER_MSEC))
+				      1, 1000 * USEC_PER_MSEC))
 		dev_err(&slot->mmc->class_dev,
 			"Timeout sending command (cmd %#x arg %#x status %#x)\n",
 			cmd, arg, cmd_status);
@@ -426,9 +452,10 @@ static void dw_mci_start_command(struct dw_mci *host,
 
 	mci_writel(host, CMDARG, cmd->arg);
 	wmb(); /* drain writebuffer */
-	dw_mci_wait_while_busy(host, cmd_flags);
+	dw_mci_wait_while_busy(host, cmd_flags, host->slot);
 
-	mci_writel(host, CMD, cmd_flags | SDMMC_CMD_START);
+	mci_writel(host, CMD, cmd_flags | SDMMC_CMD_START |
+		   SDMMC_CMD_CARD_NUM(host->slot->id));
 
 	/* response expected command only */
 	if (cmd_flags & SDMMC_CMD_RESP_EXP)
@@ -2649,20 +2695,30 @@ static void dw_mci_cmd_interrupt(struct dw_mci *host, u32 status)
 
 static void dw_mci_handle_cd(struct dw_mci *host)
 {
-	struct dw_mci_slot *slot = host->slot;
+	int i;
+	struct dw_mci_slot *slot;
+	unsigned long delay = 0;
 
-	if (slot->mmc->ops->card_event)
-		slot->mmc->ops->card_event(slot->mmc);
-	mmc_detect_change(slot->mmc,
-		msecs_to_jiffies(host->pdata->detect_delay_ms));
+	for (i = 0; i < host->num_slots; i++) {
+		slot = host->slots[i];
+		if (slot == NULL)
+			continue;
+		if (slot->mmc->ops->card_event)
+			slot->mmc->ops->card_event(slot->mmc);
+		mmc_detect_change(slot->mmc,
+			msecs_to_jiffies(host->pdata->detect_delay_ms) +
+			delay);
+		delay += 2 * HZ;
+	}
 }
 
 static irqreturn_t dw_mci_interrupt(int irq, void *dev_id)
 {
 	struct dw_mci *host = dev_id;
 	u32 pending;
-	struct dw_mci_slot *slot = host->slot;
+	struct dw_mci_slot *slot;
 	unsigned long irqflags;
+	int i;
 
 	pending = mci_readl(host, MINTSTS); /* read-only mask reg */
 
@@ -2750,11 +2806,16 @@ static irqreturn_t dw_mci_interrupt(int irq, void *dev_id)
 			dw_mci_handle_cd(host);
 		}
 
-		if (pending & SDMMC_INT_SDIO(slot->sdio_id)) {
-			mci_writel(host, RINTSTS,
-				   SDMMC_INT_SDIO(slot->sdio_id));
-			__dw_mci_enable_sdio_irq(slot, 0);
-			sdio_signal_irq(slot->mmc);
+		for (i = 0; i < host->num_slots; i++) {
+			slot = host->slots[i];
+			if (slot == NULL)
+				continue;
+			if (pending & SDMMC_INT_SDIO(slot->sdio_id)) {
+				mci_writel(host, RINTSTS,
+					   SDMMC_INT_SDIO(slot->sdio_id));
+				__dw_mci_enable_sdio_irq(slot, 0);
+				sdio_signal_irq(slot->mmc);
+			}
 		}
 
 	}
@@ -2836,7 +2897,43 @@ static int dw_mci_init_slot_caps(struct dw_mci_slot *slot)
 	return 0;
 }
 
-static int dw_mci_init_slot(struct dw_mci *host)
+static void mmc_parse_slot_cfg(struct mmc_host *mmc)
+{
+	struct dw_mci_slot *slot = mmc_priv(mmc);
+	struct fwnode_handle *child;
+	u32 bus_width, id;
+
+	/* Find the node for this card. */
+	device_for_each_child_node(mmc->parent, child) {
+		if (!fwnode_property_read_u32(child, "reg", &id) &&
+		    id == slot->id)
+			break;
+	}
+
+	if (!child)
+		return;
+
+	if (!fwnode_property_read_u32(child, "bus-width", &bus_width)) {
+		switch (bus_width) {
+		case 8:
+			/* Hosts capable of 8-bit can also do 4 bits. */
+			mmc->caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_4_BIT_DATA;
+			break;
+		case 4:
+			/* 4 bits only. */
+			mmc->caps &= ~MMC_CAP_8_BIT_DATA;
+			mmc->caps |= MMC_CAP_4_BIT_DATA;
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (fwnode_property_read_bool(child, "disable-wp"))
+		mmc->caps2 |= MMC_CAP2_NO_WRITE_PROTECT;
+}
+
+static int dw_mci_init_slot(struct dw_mci *host, unsigned int id)
 {
 	struct mmc_host *mmc;
 	struct dw_mci_slot *slot;
@@ -2847,11 +2944,11 @@ static int dw_mci_init_slot(struct dw_mci *host)
 		return -ENOMEM;
 
 	slot = mmc_priv(mmc);
-	slot->id = 0;
+	slot->id = id;
 	slot->sdio_id = host->sdio_id0 + slot->id;
 	slot->mmc = mmc;
 	slot->host = host;
-	host->slot = slot;
+	host->slots[id] = slot;
 
 	mmc->ops = &dw_mci_ops;
 
@@ -2863,10 +2960,14 @@ static int dw_mci_init_slot(struct dw_mci *host)
 	if (!mmc->ocr_avail)
 		mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
 
+	/* Parse common configuration. */
 	ret = mmc_of_parse(mmc);
 	if (ret)
 		goto err_host_allocated;
 
+	/* Check per-slot configuration. */
+	mmc_parse_slot_cfg(mmc);
+
 	ret = dw_mci_init_slot_caps(slot);
 	if (ret)
 		goto err_host_allocated;
@@ -2916,7 +3017,7 @@ static void dw_mci_cleanup_slot(struct dw_mci_slot *slot)
 {
 	/* Debugfs stuff is cleaned up by mmc core */
 	mmc_remove_host(slot->mmc);
-	slot->host->slot = NULL;
+	slot->host->slots[slot->id] = NULL;
 	mmc_free_host(slot->mmc);
 }
 
@@ -3152,6 +3253,12 @@ static struct dw_mci_board *dw_mci_parse_dt(struct dw_mci *host)
 			return ERR_PTR(-EPROBE_DEFER);
 	}
 
+ 	/* find out number of slots supported */
+	if (device_property_read_u32(dev, "num-slots", &pdata->num_slots) ||
+	    pdata->num_slots > DW_MMC_SLOT_NUM)
+		pdata->num_slots = DW_MMC_SLOT_NUM;
+	host->num_slots = pdata->num_slots;
+
 	if (device_property_read_u32(dev, "fifo-depth", &pdata->fifo_depth))
 		dev_info(dev,
 			 "fifo-depth property not found, using value of FIFOTH register as default\n");
@@ -3185,29 +3292,37 @@ static struct dw_mci_board *dw_mci_parse_dt(struct dw_mci *host)
 
 static void dw_mci_enable_cd(struct dw_mci *host)
 {
+	struct dw_mci_slot *slot;
 	unsigned long irqflags;
 	u32 temp;
+	int i;
 
-	/*
-	 * No need for CD if all slots have a non-error GPIO
-	 * as well as broken card detection is found.
-	 */
-	if (host->slot->mmc->caps & MMC_CAP_NEEDS_POLL)
-		return;
+	for (i = 0; i < host->num_slots; i++) {
+		slot = host->slots[i];
+		if (slot == NULL)
+			continue;
+		/*
+		 * No need for CD if all slots have a non-error GPIO
+		 * as well as broken card detection is found.
+		 */
+		if (slot->mmc->caps & MMC_CAP_NEEDS_POLL)
+			continue;
 
-	if (mmc_gpio_get_cd(host->slot->mmc) < 0) {
-		spin_lock_irqsave(&host->irq_lock, irqflags);
-		temp = mci_readl(host, INTMASK);
-		temp  |= SDMMC_INT_CD;
-		mci_writel(host, INTMASK, temp);
-		spin_unlock_irqrestore(&host->irq_lock, irqflags);
+		if (mmc_gpio_get_cd(slot->mmc) < 0) {
+			spin_lock_irqsave(&host->irq_lock, irqflags);
+			temp = mci_readl(host, INTMASK);
+			temp |= SDMMC_INT_CD;
+			mci_writel(host, INTMASK, temp);
+			spin_unlock_irqrestore(&host->irq_lock, irqflags);
+			break;
+		}
 	}
 }
 
 int dw_mci_probe(struct dw_mci *host)
 {
 	const struct dw_mci_drv_data *drv_data = host->drv_data;
-	int width, i, ret = 0;
+	int width, i, ret = 0, num_slots;
 	u32 fifo_size;
 
 	if (!host->pdata) {
@@ -3386,11 +3503,20 @@ int dw_mci_probe(struct dw_mci *host)
 		 host->irq, width, fifo_size);
 
 	/* We need at least one slot to succeed */
-	ret = dw_mci_init_slot(host);
-	if (ret) {
-		dev_dbg(host->dev, "slot %d init failed\n", i);
-		goto err_dmaunmap;
+	num_slots = SDMMC_GET_SLOT_NUM(mci_readl(host, HCON));
+	if (num_slots < host->num_slots)
+		host->num_slots = num_slots;
+	for (i = 0; i < host->num_slots; i++) {
+		ret = dw_mci_init_slot(host, i);
+		if (ret) {
+			dev_dbg(host->dev, "slot %d init failed\n", i);
+			goto err_dmaunmap;
+		}
+		/* Add a delay for each additional slot. */
+		if (host->num_slots > 1)
+			msleep(2000);
 	}
+	host->slot = host->slots[0];
 
 	/* Now that slots are all setup, we can enable card detect */
 	dw_mci_enable_cd(host);
@@ -3416,9 +3542,13 @@ int dw_mci_probe(struct dw_mci *host)
 
 void dw_mci_remove(struct dw_mci *host)
 {
+	int i;
+
 	dev_dbg(host->dev, "remove slot\n");
-	if (host->slot)
-		dw_mci_cleanup_slot(host->slot);
+	for (i = 0; i < host->num_slots; i++) {
+		if (host->slots[i] != NULL)
+			dw_mci_cleanup_slot(host->slots[i]);
+	}
 
 	mci_writel(host, RINTSTS, 0xFFFFFFFF);
 	mci_writel(host, INTMASK, 0); /* disable all mmc interrupt first */
@@ -3461,7 +3591,8 @@ int dw_mci_runtime_suspend(struct device *dev)
 
 int dw_mci_runtime_resume(struct device *dev)
 {
-	int ret = 0;
+	int i, ret = 0;
+	struct dw_mci_slot *slot;
 	struct dw_mci *host = dev_get_drvdata(dev);
 
 	if (host->slot &&
@@ -3501,12 +3632,16 @@ int dw_mci_runtime_resume(struct device *dev)
 		   DW_MCI_ERROR_FLAGS);
 	mci_writel(host, CTRL, SDMMC_CTRL_INT_ENABLE);
 
+	for (i = 0; i < host->num_slots; i++) {
+		slot = host->slots[i];
+		if (slot == NULL)
+			continue;
+		if (slot->mmc->pm_flags & MMC_PM_KEEP_POWER)
+			dw_mci_set_ios(slot->mmc, &slot->mmc->ios);
 
-	if (host->slot->mmc->pm_flags & MMC_PM_KEEP_POWER)
-		dw_mci_set_ios(host->slot->mmc, &host->slot->mmc->ios);
-
-	/* Force setup bus to guarantee available clock output */
-	dw_mci_setup_bus(host->slot, true);
+		/* Force setup bus to guarantee available clock output */
+		dw_mci_setup_bus(slot, true);
+	}
 
 	/* Now that slots are all setup, we can enable card detect */
 	dw_mci_enable_cd(host);
